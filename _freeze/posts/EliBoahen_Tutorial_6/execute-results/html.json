{
  "hash": "fe419c237591b0bbb38854f496c16176",
  "result": {
    "markdown": "---\ntitle: \"Eli Boahen | Tutorial 6\"\nauthor: \"Eli Boahen\"\ndescription: \"Tutorial 6 Completion\"\ndate: \"07/13/2023\"\nformat:\n  html:\n    toc: true\n    code-fold: true\n    code-copy: true\n    code-tools: true\ncategories:\n  - Tutorial6\n  - EliBoahen\n---\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(tidyverse)\n\nknitr::opts_chunk$set(echo = TRUE)\n```\n:::\n\n\n## What did you learn?\nHow to make my data pretty :D\n\n## What did you remember?\n`geom_violin` did not do what I thought it was gonna do. And honestly, visualizations in R are not as hard as I thought they were.\n\n## Anything you didn't understand?\nI still don't get why `pseo` doesn't work for me and is not listed in `R`\n\n::: {.cell}\n\n```{.r .cell-code}\ndata\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nfunction (..., list = character(), package = NULL, lib.loc = NULL, \n    verbose = getOption(\"verbose\"), envir = .GlobalEnv, overwrite = TRUE) \n{\n    fileExt <- function(x) {\n        db <- grepl(\"\\\\.[^.]+\\\\.(gz|bz2|xz)$\", x)\n        ans <- sub(\".*\\\\.\", \"\", x)\n        ans[db] <- sub(\".*\\\\.([^.]+\\\\.)(gz|bz2|xz)$\", \"\\\\1\\\\2\", \n            x[db])\n        ans\n    }\n    my_read_table <- function(...) {\n        lcc <- Sys.getlocale(\"LC_COLLATE\")\n        on.exit(Sys.setlocale(\"LC_COLLATE\", lcc))\n        Sys.setlocale(\"LC_COLLATE\", \"C\")\n        read.table(...)\n    }\n    stopifnot(is.character(list))\n    names <- c(as.character(substitute(list(...))[-1L]), list)\n    if (!is.null(package)) {\n        if (!is.character(package)) \n            stop(\"'package' must be a character vector or NULL\")\n    }\n    paths <- find.package(package, lib.loc, verbose = verbose)\n    if (is.null(lib.loc)) \n        paths <- c(path.package(package, TRUE), if (!length(package)) getwd(), \n            paths)\n    paths <- unique(normalizePath(paths[file.exists(paths)]))\n    paths <- paths[dir.exists(file.path(paths, \"data\"))]\n    dataExts <- tools:::.make_file_exts(\"data\")\n    if (length(names) == 0L) {\n        db <- matrix(character(), nrow = 0L, ncol = 4L)\n        for (path in paths) {\n            entries <- NULL\n            packageName <- if (file_test(\"-f\", file.path(path, \n                \"DESCRIPTION\"))) \n                basename(path)\n            else \".\"\n            if (file_test(\"-f\", INDEX <- file.path(path, \"Meta\", \n                \"data.rds\"))) {\n                entries <- readRDS(INDEX)\n            }\n            else {\n                dataDir <- file.path(path, \"data\")\n                entries <- tools::list_files_with_type(dataDir, \n                  \"data\")\n                if (length(entries)) {\n                  entries <- unique(tools::file_path_sans_ext(basename(entries)))\n                  entries <- cbind(entries, \"\")\n                }\n            }\n            if (NROW(entries)) {\n                if (is.matrix(entries) && ncol(entries) == 2L) \n                  db <- rbind(db, cbind(packageName, dirname(path), \n                    entries))\n                else warning(gettextf(\"data index for package %s is invalid and will be ignored\", \n                  sQuote(packageName)), domain = NA, call. = FALSE)\n            }\n        }\n        colnames(db) <- c(\"Package\", \"LibPath\", \"Item\", \"Title\")\n        footer <- if (missing(package)) \n            paste0(\"Use \", sQuote(paste(\"data(package =\", \".packages(all.available = TRUE))\")), \n                \"\\n\", \"to list the data sets in all *available* packages.\")\n        else NULL\n        y <- list(title = \"Data sets\", header = NULL, results = db, \n            footer = footer)\n        class(y) <- \"packageIQR\"\n        return(y)\n    }\n    paths <- file.path(paths, \"data\")\n    for (name in names) {\n        found <- FALSE\n        for (p in paths) {\n            tmp_env <- if (overwrite) \n                envir\n            else new.env()\n            if (file_test(\"-f\", file.path(p, \"Rdata.rds\"))) {\n                rds <- readRDS(file.path(p, \"Rdata.rds\"))\n                if (name %in% names(rds)) {\n                  found <- TRUE\n                  if (verbose) \n                    message(sprintf(\"name=%s:\\t found in Rdata.rds\", \n                      name), domain = NA)\n                  thispkg <- sub(\".*/([^/]*)/data$\", \"\\\\1\", p)\n                  thispkg <- sub(\"_.*$\", \"\", thispkg)\n                  thispkg <- paste0(\"package:\", thispkg)\n                  objs <- rds[[name]]\n                  lazyLoad(file.path(p, \"Rdata\"), envir = tmp_env, \n                    filter = function(x) x %in% objs)\n                  break\n                }\n                else if (verbose) \n                  message(sprintf(\"name=%s:\\t NOT found in names() of Rdata.rds, i.e.,\\n\\t%s\\n\", \n                    name, paste(names(rds), collapse = \",\")), \n                    domain = NA)\n            }\n            if (file_test(\"-f\", file.path(p, \"Rdata.zip\"))) {\n                warning(\"zipped data found for package \", sQuote(basename(dirname(p))), \n                  \".\\nThat is defunct, so please re-install the package.\", \n                  domain = NA)\n                if (file_test(\"-f\", fp <- file.path(p, \"filelist\"))) \n                  files <- file.path(p, scan(fp, what = \"\", quiet = TRUE))\n                else {\n                  warning(gettextf(\"file 'filelist' is missing for directory %s\", \n                    sQuote(p)), domain = NA)\n                  next\n                }\n            }\n            else {\n                files <- list.files(p, full.names = TRUE)\n            }\n            files <- files[grep(name, files, fixed = TRUE)]\n            if (length(files) > 1L) {\n                o <- match(fileExt(files), dataExts, nomatch = 100L)\n                paths0 <- dirname(files)\n                paths0 <- factor(paths0, levels = unique(paths0))\n                files <- files[order(paths0, o)]\n            }\n            if (length(files)) {\n                for (file in files) {\n                  if (verbose) \n                    message(\"name=\", name, \":\\t file= ...\", .Platform$file.sep, \n                      basename(file), \"::\\t\", appendLF = FALSE, \n                      domain = NA)\n                  ext <- fileExt(file)\n                  if (basename(file) != paste0(name, \".\", ext)) \n                    found <- FALSE\n                  else {\n                    found <- TRUE\n                    zfile <- file\n                    zipname <- file.path(dirname(file), \"Rdata.zip\")\n                    if (file.exists(zipname)) {\n                      Rdatadir <- tempfile(\"Rdata\")\n                      dir.create(Rdatadir, showWarnings = FALSE)\n                      topic <- basename(file)\n                      rc <- .External(C_unzip, zipname, topic, \n                        Rdatadir, FALSE, TRUE, FALSE, FALSE)\n                      if (rc == 0L) \n                        zfile <- file.path(Rdatadir, topic)\n                    }\n                    if (zfile != file) \n                      on.exit(unlink(zfile))\n                    switch(ext, R = , r = {\n                      library(\"utils\")\n                      sys.source(zfile, chdir = TRUE, envir = tmp_env)\n                    }, RData = , rdata = , rda = load(zfile, \n                      envir = tmp_env), TXT = , txt = , tab = , \n                      tab.gz = , tab.bz2 = , tab.xz = , txt.gz = , \n                      txt.bz2 = , txt.xz = assign(name, my_read_table(zfile, \n                        header = TRUE, as.is = FALSE), envir = tmp_env), \n                      CSV = , csv = , csv.gz = , csv.bz2 = , \n                      csv.xz = assign(name, my_read_table(zfile, \n                        header = TRUE, sep = \";\", as.is = FALSE), \n                        envir = tmp_env), found <- FALSE)\n                  }\n                  if (found) \n                    break\n                }\n                if (verbose) \n                  message(if (!found) \n                    \"*NOT* \", \"found\", domain = NA)\n            }\n            if (found) \n                break\n        }\n        if (!found) {\n            warning(gettextf(\"data set %s not found\", sQuote(name)), \n                domain = NA)\n        }\n        else if (!overwrite) {\n            for (o in ls(envir = tmp_env, all.names = TRUE)) {\n                if (exists(o, envir = envir, inherits = FALSE)) \n                  warning(gettextf(\"an object named %s already exists and will not be overwritten\", \n                    sQuote(o)))\n                else assign(o, get(o, envir = tmp_env, inherits = FALSE), \n                  envir = envir)\n            }\n            rm(tmp_env)\n        }\n    }\n    invisible(names)\n}\n<bytecode: 0x00000284fc90df28>\n<environment: namespace:utils>\n```\n:::\n:::\n\n\n## Something you would change?\nI've been loving the glossary. I like this question at the end of each tutorial.\n\n\nBest wishes,\nEli",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}